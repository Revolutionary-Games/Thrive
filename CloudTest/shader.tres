[gd_resource type="Shader" format=2]

[resource]
code = "shader_type spatial;
uniform int MAX_STEPS = 1450; 
uniform float MAX_DIST = 7000;
uniform float MIN_HIT_DIST = 0.001f; // hit depth threshold
uniform sampler3D da;
uniform float b;
uniform float sigma;
uniform float densityMult= 2f;
void vertex() {
  POSITION = vec4(VERTEX, 1.0);
}

float gauss(float x)
{
	float pi = 3.145;
	float a = 1f/(sigma * sqrt(2f*pi));
	return a*exp(-pow((x-b),2)/(2f*pow(sigma,2)));
}

float signedDistance(vec3 center, float radius, vec3 point)
{
	return length(center - point) - radius;
	
}
vec4 sdf(vec3 point)
{
	vec3 circles[3]= vec3[3] (vec3(1,1,0),vec3(13,73,-10),vec3(-10,-10,11));
	float m = signedDistance(circles[2],30,point);
	float d;
	float nrCircles = 0f;
	vec3 center = circles[2];
	for (int i = 0;i<3;i++)
		{
			d = signedDistance(circles[i],30,point);
			if (d < 0f)
				nrCircles += 1f;
			if(abs(d) < abs(m)){
				m = d;
				center = circles[i];
			}
		}
	return vec4(center,nrCircles);
}
vec3 raymarch(vec3 rayDir,vec3 cameraPos)
{
 	float dstToSphere = 0f;
	float dstToExit = 0f;
    float depth = 0.0;
	float density = 0f;
	float dist;
	float totalDist =0f;
	vec3 pos;
	//Coordonate pentru 2 puncte de intersectie cu raza
    for (int i=0; depth<MAX_DIST && i<MAX_STEPS; ++i)
    {	
        pos = cameraPos + rayDir * depth;
		vec3 npos = cameraPos + rayDir * (depth +0.01f);
		vec4 sdfInfo = sdf(pos);
		float nrCircles = sdfInfo.w;
		dist = abs(signedDistance(sdfInfo.xyz,30,pos));
		float ndist = signedDistance(sdfInfo.xyz,30,npos);
        if (dist < MIN_HIT_DIST ) {
			dist += 0.1f;
			if (ndist < 0f)
			{
				if (dstToSphere == 0f)
				dstToSphere = depth;
				vec3 vecToCenter = normalize(sdfInfo.xyz - pos);
				float cosine = dot(vecToCenter,rayDir)/length(vecToCenter)/length(rayDir);
				dstToExit = (2f*30f*cosine);
				vec3 dest;
				for( float j =1f;j<5f;j++){
					dest = cameraPos + rayDir * (depth + dstToExit/4f*j);
					float newDist = abs(signedDistance(sdfInfo.xyz,30f,dest));
					density += gauss(newDist) *newDist* densityMult;
				}
				
			}
        }
        depth += dist;
    }
    return vec3 (dstToSphere ,abs(totalDist), density);
}

void fragment()
{
	float depth = texture(DEPTH_TEXTURE, SCREEN_UV).x;
	vec3 ndc = vec3(SCREEN_UV, depth) * 2.0 - 1.0;
	vec4 view = INV_PROJECTION_MATRIX * vec4(ndc, 1.0);
	view.xyz /= view.w;
	float linear_depth = -view.z;
	
	vec3 worldCamera = (CAMERA_MATRIX * vec4(0f,0f,0f,1f)).xyz;
	vec4 world = CAMERA_MATRIX * view;
    vec3 world_position = world.xyz / world.w;
	
	
	vec3 rayDir = normalize(world_position - worldCamera);
	vec3 rayInfo = raymarch(rayDir, worldCamera);
	float distToSphere = rayInfo.x;
	float distToSphereExit = rayInfo.y;

	if (distToSphereExit == 0f)
		distToSphereExit = distToSphere;
	vec3 rayColor = vec3(0f,0f,0f);
	if (rayInfo.x != 0f)
		rayColor = vec3(2f,0.1f,0.5f);

	ALBEDO = rayColor.xyz;
	
	// Alpha calculation
	float dist = (abs(distToSphere-distToSphereExit));
	float density = rayInfo.z;
	float alpha =  1f-exp(-density/1f);
//	alpha= min (1f,alpha);
	ALPHA = alpha;

	if (rayColor.xyz == vec3 (0f,0f,0f) || linear_depth < abs(distToSphere) )//|| density > 1.2f )
		ALPHA = 0f;
		


}"
