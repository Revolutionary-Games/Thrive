using System;
using System.Globalization;
using Godot;

/// <summary>
///   An item in the saves list. This is a class to handle loading its data from the file
/// </summary>
public class SaveListItem : PanelContainer
{
    [Export]
    public bool Selectable;

    [Export]
    public bool Loadable = true;

    [Export]
    public NodePath SaveNamePath = null!;

    [Export]
    public NodePath ScreenshotPath = null!;

    [Export]
    public NodePath VersionPath = null!;

    [Export]
    public NodePath VersionWarningPath = null!;

    [Export]
    public NodePath TypePath = null!;

    [Export]
    public NodePath CreatedAtPath = null!;

    [Export]
    public NodePath CreatedByPath = null!;

    [Export]
    public NodePath CreatedOnPlatformPath = null!;

    [Export]
    public NodePath DescriptionPath = null!;

    [Export]
    public NodePath LoadButtonPath = null!;

    [Export]
    public NodePath HighlightPath = null!;

    private static readonly object ResizeLock = new();

    private Label? saveNameLabel;
    private TextureRect screenshot = null!;
    private Label version = null!;
    private Label versionWarning = null!;
    private Label type = null!;
    private Label createdAt = null!;
    private Label createdBy = null!;
    private Label createdOnPlatform = null!;
    private Label description = null!;
    private Button loadButton = null!;
    private Panel? highlightPanel;

    private string saveName = string.Empty;
    private int versionDifference;

    private bool loadingData;
    private SaveInfoAndScreenshot? saveInfoLoadTask;

    private bool highlighted;
    private bool selected;

    private bool isBroken;
    private bool isKnownIncompatible;
    private bool isUpgradeable;
    private bool isIncompatiblePrototype;

    [Signal]
    public delegate void OnSelectedChanged();

    [Signal]
    public delegate void OnDoubleClicked();

    [Signal]
    public delegate void OnDeleted();

    [Signal]
    public delegate void OnOldSaveLoaded();

    [Signal]
    public delegate void OnUpgradeableSaveLoaded(string saveName, bool incompatible);

    [Signal]
    public delegate void OnBrokenSaveLoaded();

    [Signal]
    public delegate void OnNewSaveLoaded();

    [Signal]
    public delegate void OnKnownIncompatibleLoaded();

    [Signal]
    public delegate void OnDifferentVersionPrototypeLoaded();

    /// <summary>
    ///   Triggered when this is loaded without a problem. This is triggered when the load is already in progress
    ///   so this is more of an informative callback for components that need to know when a save load was done.
    /// </summary>
    [Signal]
    public delegate void OnProblemFreeSaveLoaded(string saveName);

    public string SaveName
    {
        get => saveName;
        set
        {
            if (value == saveName)
                return;

            saveName = value;
            LoadSaveData();
            UpdateName();
        }
    }

    public bool Highlighted
    {
        get => highlighted;
        set
        {
            highlighted = value;
            UpdateHighlighting();
        }
    }

    public bool Selected
    {
        get
        {
            if (!Selectable)
                return false;

            return selected;
        }
        set
        {
            if (!Selectable)
                throw new InvalidOperationException();

            selected = value;
            UpdateHighlighting();
        }
    }

    public override void _Ready()
    {
        if (string.IsNullOrEmpty(SaveName))
            throw new InvalidOperationException($"{nameof(SaveName)} is required");

        saveNameLabel = GetNode<Label>(SaveNamePath);
        screenshot = GetNode<TextureRect>(ScreenshotPath);
        version = GetNode<Label>(VersionPath);
        versionWarning = GetNode<Label>(VersionWarningPath);
        type = GetNode<Label>(TypePath);
        createdAt = GetNode<Label>(CreatedAtPath);
        createdBy = GetNode<Label>(CreatedByPath);
        createdOnPlatform = GetNode<Label>(CreatedOnPlatformPath);
        description = GetNode<Label>(DescriptionPath);
        loadButton = GetNode<Button>(LoadButtonPath);
        highlightPanel = GetNode<Panel>(HighlightPath);

        loadButton.Visible = Loadable;

        UpdateName();
        UpdateHighlighting();
    }

    public override void _Process(float delta)
    {
        if (!loadingData)
            return;

        if (!saveInfoLoadTask!.Loaded)
            return;

        var save = saveInfoLoadTask.Save ?? throw new Exception("Save info resource didn't load a save instance");
        var screenshotImage = saveInfoLoadTask.Screenshot;
        saveInfoLoadTask = null;

        isBroken = save.Info.Type == SaveInformation.SaveType.Invalid;

        // Screenshot (if present, saves can have a missing screenshot)
        if (screenshotImage != null)
        {
            screenshot.Texture = screenshotImage;
        }

        // General info

        // If save is valid compare version numbers
        if (!isBroken)
        {
            versionDifference = VersionUtils.Compare(save.Info.ThriveVersion, Constants.Version);
        }
        else
        {
            versionDifference = 0;
        }

        if (versionDifference != 0)
        {
            if (save.Info.IsPrototype)
            {
                isIncompatiblePrototype = true;
            }
            else
            {
                if (versionDifference < 0 && SaveUpgrader.CanUpgradeSaveToVersion(save.Info))
                {
                    isUpgradeable = true;
                }

                if (SaveHelper.IsKnownIncompatible(save.Info.ThriveVersion))
                {
                    isKnownIncompatible = true;
                }
            }
        }

        version.Text = save.Info.ThriveVersion;
        versionWarning.Visible = versionDifference != 0;
        type.Text = save.Info.TranslatedSaveTypeString;
        createdAt.Text = save.Info.CreatedAt.ToString("G", CultureInfo.CurrentCulture);
        createdBy.Text = save.Info.Creator;
        createdOnPlatform.Text = save.Info.Platform;
        description.Text = save.Info.Description;

        loadingData = false;
    }

    public override void _GuiInput(InputEvent @event)
    {
        if (@event is InputEventMouseButton { Pressed: true, ButtonIndex: (int)ButtonList.Left } mouse)
        {
            AcceptEvent();

            if (mouse.Doubleclick)
            {
                EmitSignal(nameof(OnDoubleClicked));
            }
            else
            {
                OnSelect();
            }
        }
    }

    public void LoadThisSave()
    {
        if (isBroken)
        {
            EmitSignal(nameof(OnBrokenSaveLoaded));
            return;
        }

        if (isIncompatiblePrototype)
        {
            EmitSignal(nameof(OnDifferentVersionPrototypeLoaded));
            return;
        }

        if (versionDifference < 0 && isUpgradeable)
        {
            EmitSignal(nameof(OnUpgradeableSaveLoaded), SaveName, isKnownIncompatible);
            return;
        }

        if (isKnownIncompatible)
        {
            EmitSignal(nameof(OnKnownIncompatibleLoaded));
            return;
        }

        if (versionDifference < 0)
        {
            EmitSignal(nameof(OnOldSaveLoaded));
            return;
        }

        if (versionDifference > 0)
        {
            EmitSignal(nameof(OnNewSaveLoaded));
            return;
        }

        TransitionManager.Instance.AddSequence(ScreenFade.FadeType.FadeOut, 0.3f, LoadSave, true);
    }

    private void LoadSave()
    {
        SaveHelper.LoadSave(SaveName);
        EmitSignal(nameof(OnProblemFreeSaveLoaded), saveName);
    }

    private void LoadSaveData()
    {
        loadingData = true;

        saveInfoLoadTask = new SaveInfoAndScreenshot(saveName);

        // Resource manager is now used to limit how big of a lag spike opening the pause menu causes
        ResourceManager.Instance.QueueLoad(saveInfoLoadTask);
    }

    private void UpdateName()
    {
        if (saveNameLabel != null)
            saveNameLabel.Text = saveName.Replace(Constants.SAVE_EXTENSION_WITH_DOT, string.Empty);
    }

    private void LoadSavePressed()
    {
        GUICommon.Instance.PlayButtonPressSound();

        LoadThisSave();
    }

    private void OnSelect()
    {
        if (!Selectable)
            return;

        Selected = !Selected;

        EmitSignal(nameof(OnSelectedChanged));
    }

    private void OnMouseEnter()
    {
        Highlighted = true;
    }

    private void OnMouseExit()
    {
        Highlighted = false;
    }

    private void UpdateHighlighting()
    {
        if (highlightPanel == null)
            return;

        highlightPanel.Visible = Highlighted || Selected;
    }

    private void DeletePressed()
    {
        GUICommon.Instance.PlayButtonPressSound();

        EmitSignal(nameof(OnDeleted));
    }

    private class SaveInfoAndScreenshot : IResource
    {
        private readonly string saveName;
        private (SaveInformation Info, byte[]? ScreenshotData)? data;

        public SaveInfoAndScreenshot(string saveName)
        {
            this.saveName = saveName;
        }

        // See the TODO comment in PerformPostProcessing
        public bool RequiresSyncLoad => true;
        public bool UsesPostProcessing => true;

        // See the TODO comment in PerformPostProcessing
        public bool RequiresSyncPostProcess => true;
        public float EstimatedTimeRequired => 0.025f;
        public bool LoadingPrepared { get; set; }
        public bool Loaded { get; private set; }
        public string Identifier => $"{nameof(SaveInfoAndScreenshot)}/{saveName}";

        // TODO: maybe this should switch to using the callback to update the state rather than _Process?
        public Action<IResource>? OnComplete { get; set; }

        public Save? Save { get; private set; }
        public ImageTexture? Screenshot { get; private set; }

        public void PrepareLoading()
        {
            data = Save.LoadInfoAndRawScreenshotFromSave(saveName);
        }

        public void Load()
        {
            Save = Save.ConstructSaveFromInfoAndScreenshotBuffer(saveName, data!.Value.Info, data.Value.ScreenshotData);

            // Let go of the data
            data = null;
        }

        public void PerformPostProcessing()
        {
            if (Save!.Screenshot != null)
            {
                // Rescale the screenshot to save memory etc.
                float aspectRatio = Save.Screenshot.GetWidth() / (float)Save.Screenshot.GetHeight();

                if (Save.Screenshot.GetHeight() > Constants.SAVE_LIST_SCREENSHOT_HEIGHT)
                {
                    // TODO: this seems like a Godot bug, the game crashes often when loading the saves list without
                    // this lock. See: https://github.com/godotengine/godot/issues/55528
                    // Partly resolves: https://github.com/Revolutionary-Games/Thrive/issues/2078
                    // but not for all people and save amounts
                    // Note that now as an additional workaround this uses the resource manager with sync loading
                    lock (ResizeLock)
                    {
                        Save.Screenshot.Resize((int)(Constants.SAVE_LIST_SCREENSHOT_HEIGHT * aspectRatio),
                            Constants.SAVE_LIST_SCREENSHOT_HEIGHT);
                    }
                }

                Screenshot = new ImageTexture();
                Screenshot.CreateFromImage(Save.Screenshot);
            }

            Loaded = true;
        }
    }
}
