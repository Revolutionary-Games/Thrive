using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using DefaultEcs.System;
using Godot;
using Environment = System.Environment;

/// <summary>
///   Tool that generates a multithreaded sequence of runs for systems to run in parallel. This is implemented in the
///   main module as this needs to be able to load for example <see cref="MicrobeWorldSimulation"/> that depends on
///   Godot types.
/// </summary>
public class GenerateThreadedSystems : Node
{
    private const int DefaultSeed = 334564234;
    private const string ProcessFixedDetection = "void OnProcessFixedLogic";
    private const string ProcessFrameDetection = "void ProcessFrameLogic";
    private const string AutoGeneratedTextSection1 = "// This section of the file is auto generated, do not modify!";
    private const string AutoGeneratedTextSection2 = "// Run GenerateThreadedSystems to re-generate this part";

    private readonly Regex justClosingBrace = new Regex(@"^\s*}\s*$", RegexOptions.Compiled);

    private readonly Random random;

    private readonly IReadOnlyList<(Type Class, string File)> simulationTypes =
        new List<(Type Class, string File)>
            { (typeof(MicrobeWorldSimulation), "src/microbe_stage/MicrobeWorldSimulation.cs") };

    private readonly Type systemBaseType = typeof(ISystem<>);
    private readonly Type systemWithAttribute = typeof(WithAttribute);

    // private readonly Type systemWithoutAttribute = typeof(WithoutAttribute);

    private readonly Type writesToAttribute = typeof(WritesToComponentAttribute);
    private readonly Type readsFromAttribute = typeof(ReadsComponentAttribute);
    private readonly Type runsAfterAttribute = typeof(RunsAfterAttribute);
    private readonly Type runsBeforeAttribute = typeof(RunsBeforeAttribute);
    private readonly Type runsOnMainAttribute = typeof(RunsOnMainThreadAttribute);

    private readonly Type runsOnFrameAttribute = typeof(RunsOnFrameAttribute);

    private readonly Type compilerGeneratedAttribute = typeof(CompilerGeneratedAttribute);

    private bool done;

    private GenerateThreadedSystems()
    {
        random = new Random(DefaultSeed);
    }

    public override void _Ready()
    {
        TaskExecutor.Instance.ParallelTasks = Environment.ProcessorCount;
        TaskExecutor.Instance.AddTask(new Task(Run));
    }

    public override void _Process(float delta)
    {
        if (done)
            GetTree().Quit();
    }

    public void Run()
    {
        try
        {
            RunInternal();
        }
        catch (Exception e)
        {
            GD.PrintErr("Failed to run: ", e);
            throw;
        }
        finally
        {
            done = true;
        }
    }

    private void RunInternal()
    {
        GD.Print("Beginning generation of threaded system runs, it might take a while to find valid sequences of runs");

        foreach (var (simulationClass, file) in simulationTypes)
        {
            GD.Print($"Beginning processing class {simulationClass}");

            GetSystemsInCategories(simulationClass, out var frameSystems, out var processSystems);

            // Frame systems are not currently multithreaded, so just sort those
            frameSystems = SortSingleGroupOfSystems(frameSystems).ToList();

            var frameSystemTextLines = new List<string>
            {
                "ThrowIfNotInitialized();",
                string.Empty,
                "// NOTE: not currently ran in parallel due to low frame system count",
            };

            AddSystemSingleGroupRunningLines(frameSystems, frameSystemTextLines, 0);

            var processSystemTextLines = new List<string>();

            throw new NotImplementedException();

            InsertNewProcessMethods(file, processSystemTextLines, frameSystemTextLines);

            GD.Print($"Successfully handled. {file} has been updated");
        }
    }

    private IOrderedEnumerable<SystemToSchedule> SortSingleGroupOfSystems(IEnumerable<SystemToSchedule> systems)
    {
        return systems.OrderBy(s => s, new SystemRequirementsBasedComparer()).ThenBy(s => s.OriginalOrder);
    }

    private void AddSystemSingleGroupRunningLines(IEnumerable<SystemToSchedule> systems, List<string> textOutput,
        int indent)
    {
        foreach (var system in systems)
        {
            textOutput.Add(GetIndentForText(indent) + system.GetRunningText());
        }
    }

    private string GetIndentForText(int indent)
    {
        if (indent < 1)
            return string.Empty;

        return new string(' ', indent);
    }

    private void GetSystemsInCategories(Type type, out List<SystemToSchedule> frameSystems,
        out List<SystemToSchedule> processSystems)
    {
        var all = GetAllSystemsFromClass(type);

        frameSystems = all.Where(s => s.RunsOnFrame).ToList();
        processSystems = all.Where(s => !s.RunsOnFrame).ToList();
    }

    private List<SystemToSchedule> GetAllSystemsFromClass(Type type)
    {
        var result = new List<SystemToSchedule>();

        int order = 0;

        foreach (var field in type.GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic))
        {
            // Skip automatic property backing fields
            if (field.CustomAttributes.Any(a => a.AttributeType == compilerGeneratedAttribute))
                continue;

            if (!field.FieldType.IsAssignableToGenericType(systemBaseType))
                continue;

            result.Add(new SystemToSchedule(field.FieldType, field.Name, order++));
        }

        foreach (var property in type.GetProperties(
                     BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic))
        {
            if (!property.PropertyType.IsAssignableToGenericType(systemBaseType))
                continue;

            // Skip things that are already used through fields
            if (result.Any(r => r.FieldName.Equals(property.Name, StringComparison.OrdinalIgnoreCase)))
                continue;

            result.Add(new SystemToSchedule(property.PropertyType, property.Name, order++));
        }

        foreach (var systemToSchedule in result)
        {
            ParseSystemAttributes(systemToSchedule);
        }

        ResolveSystemDependencies(result);

        // Sanity check no duplicate systems found
        if (result.GroupBy(s => s.Type).Any(g => g.Count() > 1))
            throw new Exception("Some type of system is included multiple times");

        return result;
    }

    private void ParseSystemAttributes(SystemToSchedule systemToSchedule)
    {
        systemToSchedule.RunsOnFrame = systemToSchedule.Type.GetCustomAttribute(runsOnFrameAttribute) != null;
        systemToSchedule.RunsOnMainThread = systemToSchedule.Type.GetCustomAttribute(runsOnMainAttribute) != null;

        var expectedWritesTo = new List<Type>();

        var withRaw = systemToSchedule.Type.GetCustomAttributes(systemWithAttribute);

        foreach (var attributeRaw in withRaw)
        {
            var attribute = (WithAttribute)attributeRaw;

            // TODO: handle without attributes?
            if (attribute.FilterType is not (ComponentFilterType.WithoutEither or ComponentFilterType.Without))
            {
                foreach (var componentType in attribute.ComponentTypes)
                {
                    expectedWritesTo.Add(componentType);
                }
            }
        }

        var expectedReadsFrom = new List<Type>();

        var readsRaw = systemToSchedule.Type.GetCustomAttributes(readsFromAttribute);

        foreach (var attributeRaw in readsRaw)
        {
            var attribute = (ReadsComponentAttribute)attributeRaw;

            // Convert writes to reads if exist
            expectedWritesTo.Remove(attribute.ReadsFrom);

            if (!expectedReadsFrom.Contains(attribute.ReadsFrom))
                expectedReadsFrom.Add(attribute.ReadsFrom);
        }

        var writesRaw = systemToSchedule.Type.GetCustomAttributes(writesToAttribute);

        foreach (var attributeRaw in writesRaw)
        {
            var attribute = (WritesToComponentAttribute)attributeRaw;

            if (expectedReadsFrom.Contains(attribute.WritesTo))
            {
                throw new Exception(
                    "Shouldn't specify a writes to component with already a read attribute for same type");
            }

            if (!expectedWritesTo.Contains(attribute.WritesTo))
                expectedWritesTo.Add(attribute.WritesTo);
        }
    }

    private void ResolveSystemDependencies(List<SystemToSchedule> systems)
    {
        SystemToSchedule GetSystemByType(Type type)
        {
            return systems.First(s => s.Type == type);
        }

        foreach (var system in systems)
        {
            var runsBeforeRaw = system.Type.GetCustomAttributes(runsBeforeAttribute);

            foreach (var attributeRaw in runsBeforeRaw)
            {
                var attribute = (RunsBeforeAttribute)attributeRaw;

                system.RunsBefore.Add(GetSystemByType(attribute.BeforeSystem));
            }

            var runsAfterRaw = system.Type.GetCustomAttributes(runsAfterAttribute);

            foreach (var attributeRaw in runsAfterRaw)
            {
                var attribute = (RunsAfterAttribute)attributeRaw;

                system.RunsAfter.Add(GetSystemByType(attribute.AfterSystem));
            }
        }

        // Detect cycles in runs before or runs after
        // TODO: this is likely not good enough currently
        var seenSystems = new HashSet<SystemToSchedule>();
        var tempSystems = new HashSet<SystemToSchedule>();

        foreach (var system in systems)
        {
            seenSystems.Clear();

            foreach (var runsAfter in system.RunsAfter)
            {
                seenSystems.Add(runsAfter);
                CollectRunsBefore(runsAfter, seenSystems);
            }

            if (seenSystems.Contains(system))
                throw new Exception("System has a circular running before / after relationship");

            seenSystems.Clear();

            foreach (var runsBefore in system.RunsBefore)
            {
                seenSystems.Add(runsBefore);
                CollectRunsAfter(runsBefore, seenSystems);
            }

            if (seenSystems.Contains(system))
                throw new Exception("System has a circular running before / after relationship");
        }

        // Add recursive dependencies
        foreach (var system in systems)
        {
            foreach (var runsAfter in system.RunsAfter.ToList())
            {
                CollectRunsAfter(runsAfter, system.RunsAfter);
            }

            if (system.RunsAfter.Contains(system))
                throw new Exception("System ended up running after itself after recursive resolve");

            foreach (var runsBefore in system.RunsBefore.ToList())
            {
                CollectRunsBefore(runsBefore, system.RunsBefore);
            }

            if (system.RunsBefore.Contains(system))
                throw new Exception("System ended up running before itself after recursive resolve");
        }

        // Make relationships always two-way for easier checking
        foreach (var system in systems)
        {
            foreach (var runsAfter in system.RunsAfter)
            {
                runsAfter.RunsBefore.Add(system);
            }

            foreach (var runsBefore in system.RunsBefore.ToList())
            {
                runsBefore.RunsAfter.Add(system);
            }
        }


    }

    private void CollectRunsAfter(SystemToSchedule systemToStart, HashSet<SystemToSchedule> result)
    {
        foreach (var runsAfter in systemToStart.RunsAfter)
        {
            if (result.Add(runsAfter))
                CollectRunsAfter(runsAfter, result);
        }
    }

    private void CollectRunsBefore(SystemToSchedule systemToStart, HashSet<SystemToSchedule> result)
    {
        foreach (var runsBefore in systemToStart.RunsBefore)
        {
            if (result.Add(runsBefore))
                CollectRunsBefore(runsBefore, result);
        }
    }

    private void InsertNewProcessMethods(string file, List<string> process, List<string> processFrame)
    {
        GD.Print($"Updating simulation class in {file}");
        GD.Print("Note that this relies on basic parsing of the file and won't work unless " +
            "the file is correctly intended and still has expected format of the given methods to rewrite");

        var tempFile = file + ".tmp";
        var writer = System.IO.File.CreateText(tempFile);

        bool suppress = false;

        // Used to detect the base indent of the place where we are inserting extra text
        int addedTextExtraIndent = 0;

        foreach (var line in System.IO.File.ReadLines(file))
        {
            if (!suppress)
            {
                writer.WriteLine(line);
            }
            else
            {
                // Detect closing brace at the same indent level as the opening block
                if (justClosingBrace.IsMatch(line) && DetectLineIndentationLevel(line) <= addedTextExtraIndent)
                {
                    // Found the end of the suppressed block
                    writer.WriteLine(line);
                    suppress = false;
                }

                continue;
            }

            // Detect the start of certain parts of the file and insert new text there while suppressing the existing
            // content
            if (line.Contains(ProcessFixedDetection))
            {
                addedTextExtraIndent = DetectLineIndentationLevel(line);
                suppress = true;

                WriteAutoSectionStart(line, writer, addedTextExtraIndent);

                foreach (var lineToInsert in process)
                {
                    writer.WriteLine(GetIndentForText(addedTextExtraIndent) + lineToInsert);
                }
            }
            else if (line.Contains(ProcessFrameDetection))
            {
                addedTextExtraIndent = DetectLineIndentationLevel(line);
                suppress = true;

                WriteAutoSectionStart(line, writer, addedTextExtraIndent);

                foreach (var lineToInsert in processFrame)
                {
                    writer.WriteLine(GetIndentForText(addedTextExtraIndent) + lineToInsert);
                }
            }
        }

        if (suppress)
            throw new Exception("End of output suppression not found");

        System.IO.File.Delete(file);
        System.IO.File.Move(tempFile, file);
    }

    private void WriteAutoSectionStart(string line, StreamWriter writer, int addedTextExtraIndent)
    {
        if (!line.Contains('{'))
            writer.WriteLine(GetIndentForText(addedTextExtraIndent) + '{');

        writer.WriteLine(GetIndentForText(addedTextExtraIndent) + AutoGeneratedTextSection1);
        writer.WriteLine(GetIndentForText(addedTextExtraIndent) + AutoGeneratedTextSection2);
    }

    private int DetectLineIndentationLevel(string line)
    {
        int spaceCount = 0;

        foreach (var character in line)
        {
            if (character <= ' ')
            {
                ++spaceCount;
            }
            else
            {
                break;
            }
        }

        return spaceCount;
    }

    private class SystemToSchedule
    {
        public readonly Type Type;
        public readonly string FieldName;
        public readonly int OriginalOrder;

        public bool RunsOnFrame;
        public bool RunsOnMainThread;

        public HashSet<SystemToSchedule> RunsBefore = new();
        public HashSet<SystemToSchedule> RunsAfter = new();

        public List<Type> ReadsComponents = new();
        public List<Type> WritesComponents = new();

        public SystemToSchedule(Type type, string name, int order)
        {
            Type = type;
            FieldName = name;
            OriginalOrder = order;
        }

        public bool ShouldRunBefore(SystemToSchedule other)
        {
            // This depends on the data setup to already check for conflicting (circular) run relationships
            if (RunsBefore.Contains(other))
                return true;

            if (other.RunsAfter.Contains(this))
                return true;

            return false;
        }

        public bool ShouldRunAfter(SystemToSchedule other)
        {
            if (RunsAfter.Contains(other))
                return true;

            if (other.RunsBefore.Contains(this))
                return true;

            return false;
        }

        public string GetRunningText()
        {
            return $"{FieldName}.Update(delta);";
        }

        public override string ToString()
        {
            return Type.Name;
        }
    }

    private class SystemRequirementsBasedComparer : IComparer<SystemToSchedule>
    {
        public int Compare(SystemToSchedule x, SystemToSchedule y)
        {
            if (ReferenceEquals(x, y))
                return 0;
            if (ReferenceEquals(null, y))
                return 1;
            if (ReferenceEquals(null, x))
                return -1;

            if (x.ShouldRunBefore(y))
                return -1;

            if (y.ShouldRunBefore(x))
                return 1;

            // These should be unnecessary as the simple variant already checks the other's reverse relationship
            // if (x.ShouldRunAfter(y))
            //    return 1;

            // if (y.ShouldRunAfter(x))
            //    return -1;

            // No requirement for either system to run before the other
            return 0;
        }
    }
}
